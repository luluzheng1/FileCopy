<!DOCTYPE HTML>
<!-- 
 **********************************************************

             TUFTS COMP 117 HOMEWORK ASSIGNMENT

        Fill in your name, e-mail and answers to questions
        in the sections provided below.

          All questions are marked up: <li class="q">
          All answers are marked up:   <li class="a">


     PLEASE DO NOT MODIFY ANY THING OTHER THAN THE 
     NAME, E-MAIL, AND ANSWER FIELDS (you may also add
     css declarations in the <head> if you need them,
     but usually you won't.

 **********************************************************
 -->


<html lang="en">
<head>
<meta charset="utf-8"> 
<title>Tufts COMP 117 Assignment &#8212; File Copy Project Report</title>
<link rel="stylesheet" type="text/css" href="https://www.cs.tufts.edu/comp/117/style/homework.css" />
</head>

<body class="homework">


<!-- ******************************************************
	   YOU MUST FILL IN YOUR NAME, UTLN AND EMAIL BELOW!!
         (You may copy this from an earlier assignment
                         if you like)

     ****************************************************** -->


<div class="student">
<p>
<span class="label">Student1 name: </span>
YOUR-NAME-HERE
<br>

<span class="label">UTLN: </span>
YOUR-UTLN-HERE
<br>

<span class="label">E-mail: </span>
<!-- DON'T FORGET UP UPDATE THE MAILTO: URI BELOW ALONG WITH
     YOUR EMAIL IN THE ANCHOR.  IT SHOULD LOOK LIKE:
 <a href="mailto:lady.gaga@cs.tufts.edu">lady.gaga@cs.tufts.edu</a>
--> 

<a href="mailto:YOUR-EMAIL-HERE">YOUR-EMAIL-HERE</a>
<br>
<br>
<br>
<span class="label">Student2 name: </span>
Naoki Okada
<br>
<span class="label">UTLN: </span>
nokada01
<br>

<span class="label">E-mail: </span>
<!-- DON'T FORGET UP UPDATE THE MAILTO: URI BELOW ALONG WITH
     YOUR EMAIL IN THE ANCHOR.  IT SHOULD LOOK LIKE:
 <a href="mailto:lady.gaga@cs.tufts.edu">lady.gaga@cs.tufts.edu</a>
--> 

<a href="mailto:naoki.okada@tufts.edu">naoki.okada@tufts.edu</a>

<br>
</p>
</div>




<div class="UpperLeftHeader">
<p>Tufts COMP 117 (Fall 2020):
<br>
Internet-scale Distributed Systems
</p>
</div>


<!-- - - - - - - - - - - - - - - - - - - - - - - -
		HOMEWORK TITLE
  - -  - - - - - - - - - - - - - - - - - - - - - - -->


<div class="headerdiv">
<h1>
Tufts COMP 117:<br>
File Copy Project Report
</h1>
</div>

<!-- ******************************************************

              PLEASE ANSWER QUESTIONS IN THE SECTIONS
	      LABELED class="a" (for answer)

     ****************************************************** -->




<div class="main">

<h2 id="questions">Questions</h2>
<!-- - - - - - - - - - - - - - - - - - - - - - - -
		QUESTION
  - -  - - - - - - - - - - - - - - - - - - - - - - -->
<div class="qa">

<ol class="qa">
<li class="q">What are the highest "nastiness" levels at which you believe your program will
successfully copy an entire directory full of files? (We will test your programs using those levels
on both the client and the server; if all you got working
was the end-to-end check, then please tell us how to test your work. <em>Also: if high network nastiness messes up your ability to deal with file nastiness, you can give us two pairs: e.g. Test my client and server with networknastiness=4 and filenastiness=1 or networknastiness=0 and filenastiness=3)</em></li>
<li class="a">
<!-- replace XX and YY with the actual values -->
Please test my client and server with: networknastiness=4 and filenastiness=5.
</li>

<li class="q">Is there anything else we should
know about testing your code, or what you expect it to do
(beyond what's explained in your report below)?</li>
<li class="a">
N/A
</li>

<li class="q">Did you get help from anyone other than your teammate? If "yes", then briefly explain who helped you and how.</li>
<li class="a">
TA Mert
</li>


<li class="q">(optional) Do you have any other comments on this assignment (e.g. was it worthwhile, what did you learn from it, do you have suggestions for improvment if the course is offered again)?</li>
<li class="a">
...your answer here...
</li>

</ol>

<!-- * * * * * * * * * * * * * * * * * * * * * -->
<!--            REPORT GOES HERE               -->
<!-- * * * * * * * * * * * * * * * * * * * * * -->

<h2 id="reportbody">Report</h2>

<!-- Delete the entire paragraph below 
     and replace it with your report. (Do NOT
     keep the color:grey styling on your report! :-) -->

<h3>Overview</h3>
<p>
     We approached the project by breaking it into 4 parts: reading a file, sending the packets of the file, 
     receiving the packets of the file and writing the packets to a new file. This helped us make our program modular 
     and easy to test.
</p>
<p>
     We implemented the SafePackets class that is solely used to read in a file and put all of the content into individual packets. To write to files, we implemented the SafeFile class, which takes in a series of 
     packets and writes them to a new file in order specified by packet ID. In SafePackets, our countermeasure for faulty reads was to read from the same position multiple times and assumes that the most frequently 
     read content is the right content. Similarly, in SafeFile, when writing to a file, our program writes, and reads at the same location multiple times to guess what was written, and rewrite if the content that 
     was most likely written does't match the original content.
</p>
<p>
     At the beginning of every file transmission, the client side sends metadata of the file (name, number of packets and SHA1checksum). The client then starts sending the packets one by one, and once it is done 
     sending all the packets, the client will send a special packet to the client, communicating that it has sent all packets. The server will then check which packets it has not received, and send resend requests 
     for those packets, to which the client will later respond with requested packets. This process keeps going until the server receives all packets, at which point it will write to a new file. Then the server 
     will check the newly written file against the SHA1checksum sent earlier by the client, and returns back the result of the end-to-end check.
</p>

<p>
     Our code handles all cases network nastiness and file nastiness, although a combination of both would make our filecopy program incredibly slow.  
</p>

<h3>Protocol</h3>
<p>
     very transmission, we attempt to send all packets in order from the client side. After the initial round of transmissions is over, the server will ask the client for specific files 
     that the server has not received yet. The server stores all packets in a hashtable that maps packetIDs to corresponding packet content. Thus, it is okay for packets to arrive out of order.
</p>

<p>
     Our packets have a 4-byte header, which indicates the type of the packet. and up to 252 bytes of data. The packet types include:
     <ul>
          <li>BEG/[filename]/[num_packets]/[SHA1checksum] - packet sent from client at the beginning of a file transmission that includes filename and number of packets contained in the file</li>
          <li>END/ - packet sent from client to server indicating the end of current round of transmissions (initial round of all packets or round of specific resends)</li>
          <li>REQ/ - packet sent from server to client requesting retransmission of a specific packet </li>
          <li>DON/ - packet sent from server to client indicating the end of current round of resend requests</li>
          <li>ALL/ - packet sent from server to client acknowledging that all packets of the current file have been received.</li>
          <li>PacketID [4 bytes] content[252 bytes] - packet sent from client to server that has the content of a packet and its ID</li>
     </ul>
</p>

<p>
     On the server side, we store packets in a hashmap that maps packetIDs to strings, which represent the content of the corresponding packets. This makes sure that packets don't have to 
     arrive in the exact order. Thus, when we have packets that are reordered, they can simply be inserted at the location in the hashmap determined by the packetID. The server keeps 
     track of IDs of packets it hasn't received yet, and it keeps requesting the client for packets whose IDs are missing until there are no more missing IDs.
</p>

<p>
     The server renames files only after the end-to-end check succeeds, so any file in TARGET without a .TMP suffix is correct. Furthermore, the server only starts to write packets to a file after it has received all packets.
</p>

<h3>Other Considerations</h3>
<ul>
     <li>Do you expect your code to succeed when there are errors reading or writing the disk? What ensures that it will succeed, or why do you think it might not?<br/><br/>
          When there are errors writing a packet to the disk, we attempt to detect it right away by reading the content of the same location multiple times, which 
          gives us a good idea of what was actually written. If the most likely written content doesn't match the origin content of the packet, then we attempt 
          to write the same packet again.
     </li><br/>
     <li>Are there bugs or shortcomings you know about? Are they indicated in comments in the code with NEEDSWORK?<br/><br/>
          Our program is inefficient when there are missing files.
     </li><br/>
     <li>What should we look for in the grading logs?<br/><br/>
          TBD
     </li><br/>
     <li>Which cases are you aware of (e.g. high nastiness levels or particular combinations of reordering) that you aren't trying to handle correctly? In such cases, 
          will your code detect the problem and abort (OK) or will it silently produce incorrect results?<br/><br/>
          Our program handles all leves of file nastiness and network nastiness.
     </li><br/>
     <li>Are there any cases for which your code doesn't do what you expect? Do you have any intuition why that might be?<br/><br/>
          N/A
     </li><br/>
     <li>If your code has to give up copying one file, will it go on and try others?<br/><br/>
          If the end-to-end check for a file fails, the client will keep sending the file to the server until it succeeds. 
     </li>
     <li>What should we look for in the grading logs?<br/><br/>
          TBD
     </li>
</ul>

<h3>Learning</h3>
Naoki: While this system is a relatively simple on in the grand scheme of things, there were quite a few design decisions that we had to make. Even without nastiness, we had to think
about how to best efficiently store and access the data of a file temporary on the client and server. We also had to decide on how to format the packets that are sent from the client 
to the server. Furthermore, having successful filecopy at file nastiness, network nastiness above 0 required a lot more thinking.
</div>
</div>
</body>
</html>
